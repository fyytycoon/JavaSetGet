问题一 

事务提交延时，获取锁延时问题。

```
mysql> show engine innodb status;

---TRANSACTION 1282583, ACTIVE 11937 sec

2 lock struct(s), heap size 360, 8 row lock(s), undo log entries 1

MySQL thread id 6, OS thread handle 0x7f8da2de3700, query id 190 localhost root
```

定时任务是单线程，当前定时任务阻挡了后续定时任务。

定时任务加了线程池

定时任务框架Quartz



问题二

大文件批量上传

XX:PretenureSizeThreshold 的意思是超过这个值的时候，对象直接在old区分配内存



问题三 

分词检索

使用全文检索，FULLTEXT索引   

es ik分词搜索



问题四

用户行为



问题五

## Spring创建Bean方式

1：调用构造器创建Bean：①通过index设置参数的位置；②通过type设置参数类型；

2：调用静态工厂方法创建Bean

3：调用实例工厂方法创建Bean

创建Bean实例的方式：

1) 通过构造器(有参或无参)

方式: `<bean id="" class=""/>`

2) 通过静态工厂方法

方式: `<bean id="" class="工厂类" factory-method="静态工厂方法"/>`

注: 工厂类实例没有创建

3) 通过实例工厂方法(非静态方法)

方式:

```
<bean id="factory" class="工厂类"/>
<bean id="" factory-bean="factory" factory-method="实例工厂方法"/>
```

## Spring bean 作用域

Spring支持五个作用域：singleton、prototype、request、session、global session

- singleton ：默认的作用域 spring IoC容器仅存在一个Bean实例，Bean以单例方式存在，在创建起容器时就同时自动创建了一个bean的对象
- prototype：每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象
- request：每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境
- session：同一个HTTP Session共享一个Bean，不同Session使用不同的Bean，仅适用于WebApplicationContext环境
- global-session：一般用于Portlet应用环境，该运用域仅适用于WebApplicationContext环境

## bean生命周期

简单点说就是：bean的实例化–>bean的初始化–>bean的使用–>bean的销毁

- 实例化：也就是new一个对象
- 属性注入：Spring上下文对实例化的bean进行配置（IOC注入）
- 设置beanId：如果实现BeanNameAware接口，调用setBeanName()方法设置ID
- 调用BeanFactoryAware.setBeanFactory(setBeanFactory(BeanFactory)：可以用这个方式来获取其它Bean，只需在Spring配置文件中配置一个普通的Bean就可以；
- 调用ApplicationContextAware.setApplicationContext(ApplicationContext)：与BeanFactoryAware.setBeanFactory同样作用，但是ApplicationContextAware是子接口，可以实现更多接口；
- 实例化之前调用：BeanPostProcessor.postProcessBeforeInitialization(Object obj, String s)方法调用，
- 实例化：如果在spring配置中还配置了init-method属性，会自动调用该方法；
- 实质化之后调用：如果关联BeanPostProcessor接口，调用postProcessAfterInitialization(Object obj, String s)方法，
  注：前面这里我们就完成bean的实例化；
- bean的销毁：当bean不再被使用时，就会调用destroy()方法；
- bean销毁调用方法：如果配置了destroy-method方法，会自动调用该方法；

对象单例问题，怎么解决？

把“singleton”变更为“prototype”

采用ThreadLocal进行处理，解决线程安全问题。

## Spring SpringMVC SpringBoot 常用注解说明

https://blog.csdn.net/a964921988/article/details/88933707

嵌套查询 嵌套结果



数据库隔离级别 死锁

聚合索引

分库分表

分库，分表后连表查询的问题解决方案

方案一：利用union，union all

方案二：建一张主表将你要连表查询的字段放在其中，做好索引；你还记录下用户经常查询的条件，把查出的数据缓存，以便用户经常调用。

方案三：
我们可以把经常要用到的数据写到cache中,这样以后要获取的时候直接到cache里拿。比如一天更新一次的情况（像德问的排名就是这样），我们可以写个cron，每天更新一次。

方案四：多线程处理各个分表

每个子表各开一个线程分别查询数据，然后进行合并。分表一般都是按时间进行拆分的，所以查询的时候通过也会按时间进行查询，也就做聚合的时候会用到跨表访问，如果全表数据量很大，可以借助hadoop这类工具进行统计分析。

多线程处理是可以的，不过不能开太多，要根据处理器个数和总得连接数来做衡量



跨库分页怎么做？





Linux部署流程

redis前端使用

## drools使用

- 1）在`pom.xml`中引入依赖（**update 2021/01/04**）：

  ```
  <dependency>
      <groupId>com.github.hongwen1993</groupId>
      <artifactId>fast-drools-spring-boot-starter</artifactId>
      <version>8.0.8</version>
  </dependency>
  ```

- 2）在配置文件中指定规则文件的路径

  ```
  ################## 必填属性 ##################
  # 指定规则文件目录，会自动扫描该目录下所有规则文件，决策表，以及CSV文件
  # 支持classpath资源目录，如：classpath:drools/**/*.drl
  # win 系统注意使用反斜杠，如：C:\\DRL\\
  # linux 系统注意使用斜杠，如：/usr/local/drl/
  spring.drools.path = C:\\DRL\\
  ################## 可选属性 ##################
  # 也可以指定全局的mode，选择stream或cloud（默认stream模式）
  spring.drools.mode = stream
  # 自动更新，on 或 off（默认开启）
  spring.drools.auto-update = on
  # 指定规则文件自动更新的周期，单位秒（默认30秒扫描偶一次）
  spring.drools.update = 10
  # 规则监听日志，on 或 off（默认开启）
  spring.drools.listener = on
  # 开启 drl 语法检查，on 或 off（默认关闭）
  spring.drools.verify = off
  ```

- 3）使用注解方式引入KieTemplate

  ```
  @Autowired
  private KieTemplate kieTemplate;
  ```

- 4）使用 kieTemplate 的 getKieSession 方法，指定规则文件名，就可以获取对应的 Session，可以传入多个规则文件，包括决策表

  ```
  KieSession kieSession = kieTemplate.getKieSession("rule1.drl", "rule2.drl");
  ......
  ```

- 5）结果展示

  ```
  2020-09-10 16:51:08.344 DEBUG ===>>开始更新规则文件
  2020-09-10 16:51:09.730 DEBUG ===>>插入对象：[fact 0:1:1571707504:1072693248:1:DEFAULT:NON_TRAIT:java.lang.Double:1.0]；操作规则��null
  2020-09-10 16:51:09.748 DEBUG ===>>匹配的规则：[Rule name=规则1-1, agendaGroup=MAIN, salience=0, no-loop=false]
  2020-09-10 16:51:09.761 DEBUG ===>>开始执行Java代码块，匹配规则：[Rule name=规则1-1, agendaGroup=MAIN, salience=0, no-loop=false]，评估对象：[[fact 0:1:1571707504:1072693248:1:DEFAULT:NON_TRAIT:java.lang.Double:1.0]]
  .... 执行过程忽略 ....
  2020-09-10 16:51:09.765 DEBUG ===>>结束执行Java代码块，匹配规则：[Rule name=规则1-1, agendaGroup=MAIN, salience=0, no-loop=false]，评估对象：[[fact 0:1:1571707504:1072693248:1:DEFAULT:NON_TRAIT:java.lang.Double:1.0]]
  ```

（KieTemplate 下封装了许多 Drools 的功能，许多便捷的 API 等你来发现！）





简历项目修改，禁止玩坑，换项目，增加蓝卫项目

分库分表及查询

数据库函数

分布式项目 springboot dubbo怎么整合https://www.cnblogs.com/lcbxiuxiu/p/12202627.html

多线程 volatile关键字;AQS;怎么唤醒阻塞线程
线上排查问题思路：看监控，cpu高，看是否有死循环。工具

zk集群投票

数据库索引失效

redis事务
