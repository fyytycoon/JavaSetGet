注: 本篇为个人食用《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》的消化产物。

附:

> 《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》
> 链接：https://pan.baidu.com/s/1ztb0NzdGjk5PIfZF7_PLgg 
> 提取码：e2vq



# 自动内存管理机制

## 运行时数据区域(内存模型)

JVM在执行java程序时，会把它管理的内存划分为若干区域，可以分为两大部分，

![](../img/JVM内存.png)

### 线程私有区

#### 程序计数器

> 程序计数器是一块较小的内存空间，可以看作是**当前线程所执行的字节码的行号指示器**。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。

> 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻， 一个处理器（ 对于多核处理器来说是一个内核） 都只会执行一条线程中的指令。 因此， 为了线程切换后能恢复到正确的执行位置， 每条线程都需要有一个独立的程序计数器， 各条线程之间计数器互不影响， 独立存储， 我们称这类内存区域为“线程私有”的内存 
>
> 如果执行的是JAVA方法，计数器记录正在执行的java字节码地址，如果执行的是native方法，则计数器为空。
>
> 程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。

2. 在多线程的情况下，**程序计数器用于记录当前线程执行的位置**，从而线程切换后能恢复到正确的执行位置。
   

#### 虚拟机栈

虚拟机栈描述的是**Java方法执行**的动态内存模型。是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。

**栈帧**： 每个方法执行都要创建一个栈帧，方法执行完毕，栈帧销毁。用于存储局部变量表，操作数栈，动态链接，方法出口等。**每个方法的调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈。**

**局部变量表**：存放编译期可知的各种基本**数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置），局部变量表的大小在编译期便已经可以确定，在运行时期不会发生改变。

其中64位长度的long和double类型的数据会占用2个局部变量空间(Slot)。

**栈的大小**：若 Java 虚拟机栈的内存大小不允许动态扩展，如果栈满了，StackOverFlowError，递归调用很常见。

若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 错误。	

```
可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.5+ 默认为 1M：

java -Xss2M HackTheJava
```



#### 本地方法栈

和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。

### 线程共享区

#### java堆

Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

Java 堆是垃圾收集器管理的主要区域，因此也被称作**GC 堆（Garbage Collected Heap）**.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**

在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分：

1. 新生代内存(Young Generation)
2. 老生代(Old Generation)
3. 永生代(Permanent Generation)

JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。

如果在堆中没有内存完成实例分配，且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。

可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。

```java
java -Xms1M -Xmx2M HackTheJava
```

#### 方法区

方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储**已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据**。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。

方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。

**方法区和永久代的关系**

> 《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 **方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。** 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。

 **常用参数**

JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小

```
-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
```

相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。

JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是**元空间**，元空间使用的是直接内存。

下面是一些常用参数：

```
-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
```

与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。

**为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?**

1. 整个永久代有一个 **JVM 本身设置固定大小上限**，无法进行调整，而元空间使用的是**直接内存**(本地内存)，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。

> 当你元空间溢出时会得到如下错误： `java.lang.OutOfMemoryError: MetaSpace`

你可以使用 `-XX：MaxMetaspaceSize` 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。`-XX：MetaspaceSize` 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。

1. 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。
2. 在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。

**运行时常量池**

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（**用于存放编译期生成的各种字面量和符号引用**）

既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。

**JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。**

### 直接内存

**直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。**

JDK1.4 中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）** 与**缓存区（Buffer）** 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。

本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

## 对象探秘

### 对象的创建

**一 、类加载检查** 

**首先**将去检查这个指令的参数是否能在**常量池**中定位到一个类的符号引用， **并且**检查这个符号**引用**代表的类是已被加载、 解析和初始化过。 如果没有， 那必须先执行相应的类加载过程 

**二 、分配内存** 

虚拟机将为新生对象分配内存 ，对象所需内存的大小在类加载完成后便可完全确定 ，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来 。

分配方式有 **“指针碰撞”** 和 **“空闲列表”** 两种，选择那种分配方式由 **Java 堆是否规整决定**，而 Java 堆是否规整又由所采用的**垃圾收集器是否带有压缩整理功能**决定。

![](../img/java对象创建内存分配方式.png)

**存在并发问题**

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
- **TLAB：**(本地线程分配缓冲 ) 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。哪个线程要分配内存， 就在哪个线程的TLAB上分配， 只有TLAB用完并分配新的TLAB时， 才需要同步锁定。
  虚拟机是否使用TLAB， 可以通过`-XX： +/-UseTLAB`参数来设定。 

**三 、 初始化为零值 (不包括对象头 )**

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

**四、 设置对象头**

接下来， 虚拟机要对对象进行必要的设置， 例如这个对象是哪个类的实例、 如何才能找到类的元数据信息、 对象的哈希码、 对象的GC分代年龄等信息。 这些信息存放在对象的对象头（ Object Header） 之中。 根据虚拟机当前的运行状态的不同， 如是否启用偏向锁等， 对象头会有不同的设置方式。 关于对象头的具体内容， 稍后再做详细介绍。 

**五、 执行 <init> 方法**

在上面工作都完成之后， 从虚拟机的视角来看， 一个新的对象已经产生了， 但从Java程序的视角来看， 对象创建才刚刚开始――＜ init＞ 方法还没有执行， 所有的字段都还为零。 所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

### 对象的内存布局

在HotSpot虚拟机中， 对象在内存中存储的布局可以分为3块区域： 对象头（ Header） 、实例数据（ Instance Data） 和对齐填充（ Padding） 。 

 **对象头（ Header）**

对象头包括两部分信息， 第一部分用于存储对象自身的**运行时数据** ，如哈希码（ HashCode） 、 GC分代年龄、锁状态标志、 线程持有的锁、 偏向线程ID、 偏向时间戳等 ；另外一部分是**类型指针** ，即对象指向它的类元数据的指针， 虚拟机通过这个指针来确定这个对象是哪个类的实例。 

**实例数据（ Instance Data）**

是对象真正存储的有效信息 ，也是在程序代码中所定义的各种类型的字段内容。 

这部分的存储顺序会受到虚拟机**分配策略参数**（ FieldsAllocationStyle） 和**字段在Java源码中定义顺序**的影响。 HotSpot虚拟机默认的分配策略为longs/doubles、 ints、 shorts/chars、bytes/booleans、 oops（ Ordinary Object Pointers） ， 从分配策略中可以看出， **相同宽度的字段总是被分配到一起**。 在满足这个前提条件的情况下， 在父类中定义的变量会出现在子类之前。 如果CompactFields参数值为true（ 默认为true） ， 那么子类之较窄的变量也可能会插入到父类变量的空隙之中。 

**对齐填充（ Padding）**

第三部分对齐填充并不是必然存在的， 也没有特别的含义， 它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍， 换句话说，就是对象的大小必须是8字节的整数倍。 而对象头部分正好是8字节的倍数（ 1倍或者2倍） ，因此， 当对象实例数据部分没有对齐时， 就需要通过对齐填充来补全。 

### 对象的访问定位

建立对象就是为了使用对象，我们的 Java 程序通过**栈**上的 **reference 数据**来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有**使用句柄**和**直接指针**两种：

如果使用**句柄访问**的话， 那么Java堆中将会划分出一块内存来作为句柄池， reference中存储的就是对象的句柄地址， 而句柄中包含了对象实例数据与类型数据各自的具体地址信息 。

![](../img/句柄.png)

如果使用**直接指针访问**， 那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息， 而reference中存储的直接就是对象地址 

![](../img/直接.png)

这两种对象访问方式各有优势， 使用句柄来访问的最大好处就是reference中存储的是**稳定的**句柄地址， 在对象被移动（ 垃圾收集时移动对象是非常普遍的行为） 时只会改变句柄中的实例数据指针， 而reference本身不需要修改。
**使用直接指针访问方式的最大好处就是速度更快**， 它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁， 因此这类开销积少成多后也是一项非常可观的执行成本。



## 总结

介绍下 Java 内存区域（运行时数据区）

Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）

对象的访问定位的两种方式（句柄和直接指针两种方式）





## 垃圾收集器与内存分配策略

### 对象已死吗

#### 引用计数算法 

给对象中添加一个引用计数器， 每当有一个地方引用它时， 计数器值就加1； 当引用失效时， 计数器值就减1； 任何时刻计数器为0的对象就是不可能再被使用的。

这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决**对象之间相互循环引用的问题。**

#### 可达性分析算法 

这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点， 从这些节点开始向下搜索， 搜索所走过的路径称为**引用链**（ Reference Chain） ， 当一个对象到GC Roots没有任何引用链相连（ 用图论的话来说， 就是从GC Roots到这个对象不可达） 时， 则证明此对象是不可用的。

![](../img/可达性分析算法.png)

#### 再谈引用

无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。

JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。

JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）

**1．强引用（StrongReference）**

就是指在程序代码之中普遍存在的， 类似“Object obj=**new** Object（ ） ”这类的引用， 只要强引用还存在， 垃圾收集器永远**不会回收掉被引用的对象**。 

**2．软引用（SoftReference）**

如果一个对象只具有软引用**，还有用但并非必需** 的对象 。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。

软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
```

**3．弱引用（WeakReference）**

用来描述**非必需的对象**。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，**一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存（只能存活到下一次垃圾回收发生之前）**。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。

弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```

**4．虚引用（PhantomReference）**

"虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。

**虚引用主要用来跟踪对象被垃圾回收的活动**。

**虚引用与软引用和弱引用的一个区别在于：** 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。**程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收**。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。

#### 生存还是死亡

**对象是否死亡， 至少要经历两次标记过程**： 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链， 那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize（ ） 方法。 当对象没有覆盖finalize（ ） 方法， 或者finalize（ ） 方法已经被虚拟机调用过， 虚拟机将这两种情况都视为“没有必要执行”。 如果这个对象被判定为有必要执行finalize（ ） 方法， 那么这个对象将会放置在一个叫做F-Queue的队列之中， 并在稍后由一个由虚拟机自动建立的、 低优先级的Finalizer线程去执行它。 

#### 回收方法区

永久代(方法区)的垃圾收集主要回收两部分内容 



**运行时常量池**主要回收的是**废弃的常量**。

假如在常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池。



**方法区**主要回收的是**无用的类**

判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 **“无用的类”** ：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 ClassLoader 已经被回收。
- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。



### 垃圾收集算法

#### 标记-清楚算法

该算法分为“标记”和“清除”阶段：**首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。**

它的主要不足有两个： 一个是**效率问题**， 标记和清除两个过程的效率都不高； 另一个是**空间问题**，会产生大量不连续的内存碎片，导致无法给大对象分配内存

#### 复制算法

为了**解决效率**问题， 一种称为“复制”（ Copying） 的收集算法出现了， **它将可用内存按容量划分为大小相等的两块， 每次只使用其中的一块。 当这一块的内存用完了， 就将还存活着的对象复制到另外一块上面， 然后再把已使用过的内存空间一次清理掉。** 

这样使得每次都是对整个半区进行内存回收， 内存分配时也就不用考虑内存碎片等复杂情况， 只要移动堆顶指针， 按顺序分配内存即可， 实现简单， 运行高效。 

复制收集算法在**对象存活率较高时就要进行较多的复制操作， 效率将会变低**。 更关键的是， 如果不想浪费50%的空间， 就需要有额外的空间进行分配担保， 以应对被使用的内存中所有对象都100%存活的极端情况， 所以在老年代一般不能直接选用这种算法。 



#### 标记-整理算法

根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，**而是让所有存活的对象向一端移动**，然后直接清理掉端边界以外的内存。

需要移动大量对象，处理效率比较低。

#### 分代收集算法

一般是把Java堆分为**新生代**和**老年代**， 这样就可以根据各个年代的特点采用最适当的收集算法。 在新生代中， 每次垃圾收集时都发现有大批对象死去， 只有少量存活， 那就选用**复制算法**， 只需要付出少量存活对象的复制成本就可以完成收集。 而老年代中因为对象存活率高、 没有额外空间对它进行分配担保， **就必须使用“标记―清理”或者“标记―整理”算法来进行回收。** 



### 垃圾收集器

![](../img/垃圾收集器.png)

#### CMS 收集器

CMS（ Concurrent Mark Sweep） 收集器是一种以获取最短回收停顿时间为目标的收集器。  
**现了让垃圾收集线程与用户线程（基本上）同时工作**

从名字中的**Mark Sweep**这两个词可以看出，CMS 收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

- **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
- **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- **并发清除：** 开启用户线程，同时 GC 线程开始对为标记的区域做清扫。

![](../img/CMS收集器运行原理.png)

主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

- **对 CPU 资源敏感；**
- **无法处理浮动垃圾；**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**





#### G1收集器

**G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**

被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：

- **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了**分代**的概念。
- **空间整合**：与 CMS 的“标记--清理”算法不同，G1 从整体来看是基于“**标记整理**”算法实现的收集器；从局部上来看是基于“**复制**”算法实现的。
- **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。

G1 收集器的运作大致分为以下几个步骤：

- **初始标记**
- **并发标记**
- **最终标记**
- **筛选回收**

**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)**。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。



> 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；
>
> 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。





### 内存分配与回收策略

自动内存管理最终可以归结为自动化地解决了两个问题： **给对象分配内存**以及**回收分配给对象的内存**。  

对象的内存分配， 往大方向讲， 就是在**堆**上分配（ 但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配） ， 对象主要分配在**新生代的Eden区**上， 如果启动了**本地线程分配缓冲**， 将按线程优先在**TLAB**上分配。 **少数情况下也可能会直接分配在老年代中**， 分配的规则并不是百分之百固定的， 其细节取决于当前使用的是哪一种垃圾收集器组合， 还有虚拟机中与内存相关的参数的设置。 

#### 对象优先在Eden区分配

大多数情况下， 对象在新生代Eden区中分配。 当Eden区没有足够空间进行分配时， 虚拟机将发起一次Minor GC。 



> Minor GC 和 Full GC区别
>
> Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。
>
> Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。

#### 大对象直接进入老年代

大对象是指， 需要大量连续内存空间的Java对象， 最典型的大对象就是那种很长的字符串以及数组。 

为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。

虚拟机提供了一个-XX： PretenureSizeThreshold参数， 令大于这个设置值的对象直接在老年代分配。 这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（ 新生代采用复制算法收集内存） 。 

#### 长期存活的对象将进入老年代

虚拟机给每个对象定义了一个**对象年龄计数器**。 如果对象在Eden出生并经过第一次**Minor GC**后仍然存活， 并且能被**Survivor**容纳的话， 将被移动到Survivor空间中， 并且对象年龄设为1。 对象在Survivor区中每“熬过”一次Minor GC， 年龄就增加1岁， 当它的年龄增加到一定程度（ 默认为15岁） ， 就将会被晋升到老年代中。 对象晋升老年代的年龄阈值， 可以通过参数-XX：MaxTenuringThreshold设置。 

#### 动态对象年龄判断

为了能更好地适应不同程序的内存状况， 虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代， 如果在**Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半， 年龄大于或等于该年龄的对象就可以直接进入老年代**， 无须等到MaxTenuringThreshold中要求的年龄。 

#### 空间分配担保

在发生**Minor GC之前**， 虚拟机会先检查**老年代最大可用的连续空间是否大于新生代所有对象总空间**， 如果这个条件成立， 那么Minor GC可以确保是安全的。 如果不成立， 则虚拟机会查看HandlePromotionFailure设置值**是否允许担保失败**。 如果允许， 那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小， 如果大于， 将尝试着进行一次Minor GC， 尽管这次Minor GC是有**风险(风险下面解释)**的； 如果小于， 或者HandlePromotionFailure设置不允许冒险， 那这时也要改为进行一次Full GC。

下面解释一下“冒险”是冒了什么风险， 前面提到过， **新生代使用复制收集算法**， 但为了内存利用率， 只使用其中一个Survivor空间来作为轮换备份， 因此当出现大量对象在MinorGC后仍然存活的情况（ 最极端的情况就是内存回收后新生代中所有对象都存活） ， **就需要老年代进行分配担保， 把Survivor无法容纳的对象直接进入老年代**。 与生活中的贷款担保类似， 老年代要进行这样的担保， 前提是老年代本身还有容纳这些对象的剩余空间， 一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的， 所以只好取**之前每一次回收晋升到老年代对象容量的平均大小值作为经验值**， 与老年代的剩余空间进行比较， 决定是否进行Full GC来让老年代腾出更多空间。 

取平均值进行比较其实仍然是一种动态概率的手段， 也就是说， 如果某次Minor GC存活后的对象突增， 远远高于平均值的话， 依然会导致担保失败（ Handle Promotion Failure） 。如果出现了HandlePromotionFailure失败， 那就只好在失败后重新发起一次Full GC。 虽然担保失败时绕的圈子是最大的， 但大部分情况下都还是会将HandlePromotionFailure开关打开， 避免Full GC过于频繁 



#### 堆空间结构

从垃圾回收的角度，由于现在收集器基本都采用**分代垃圾收集算法**，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间、tentired 区属于老年代等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**

大部分情况，**对象都会首先在 Eden 区域分配**，在一次Minor GC新生代垃圾回收后，如果对象还存活，**则会进入 s1("ToSurvivor")**，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），**就会被晋升到老年代中**。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。经过这次GC后，Eden区和"From"区已经被清空。这个候，"From"和"To"会交换他们的角色，也就是新的"To"就是上次GC前的“From”，新的"From"就是上次GC前的"To"。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，"To"区被填满之后，会将所有对象移动到老年代中。



#### Minor GC/Full GC 的触发条件

Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。

而 Full GC 则相对复杂，有以下条件：

1. 调用`System.gc()`，只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。
2. 老年代空间不足
3. 空间分配担保失败，使用**复制算法的 Minor GC** 需要老年代的内存空间作担保，如果**不允许担保失败**会执行一次 Full GC



### 总结

如何判断对象是否死亡／可被回收？（两种方法）。

简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。

如何判断一个常量是废弃常量

如何判断一个类是无用的类

垃圾收集有哪些算法，各自的特点？

HotSpot 为什么要分为新生代和老年代？

常见的垃圾回收器有哪些？

介绍一下 CMS,G1 收集器。

Minor Gc 和 Full GC 有什么不同呢？

堆有什么结构？

Minor GC/Full GC 的触发条件？



## JDK监控和故障处理工具

### JDK命令

#### `jps`:查看所有 Java 进程

`jps`(JVM Process Status) 命令类似 UNIX 的 `ps` 命令。

`jps`：显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID（Local Virtual Machine Identifier,LVMID）。`jps -q` ：只输出进程的本地虚拟机唯一 ID。

```
C:\Users\SnailClimb>jps
7360 NettyClient2
17396
7972 Launcher
16504 Jps
17340 NettyServer
```

`jps -l`:输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径。

```
C:\Users\SnailClimb>jps -l
7360 firstNettyDemo.NettyClient2
17396
7972 org.jetbrains.jps.cmdline.Launcher
16492 sun.tools.jps.Jps
17340 firstNettyDemo.NettyServer
```

`jps -v`：输出虚拟机进程启动时 JVM 参数。

`jps -m`：输出传递给 Java 进程 main() 函数的参数。

#### `jstat`: 监视虚拟机各种运行状态信息

**jstat 命令使用格式：**

```
jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]
```

比如 `jstat -gc -h3 31736 1000 10`表示分析进程 id 为 31736 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部。

#### jinfo： Java配置信息工具 

`jinfo vmid` :输出当前 jvm 进程的全部参数和系统属性 (第一部分是系统的属性，第二部分是 JVM 的参数)。

`jinfo -flag name vmid` :输出对应名称的参数的具体值。比如输出 MaxHeapSize、查看当前 jvm 进程是否开启打印 GC 日志 ( `-XX:PrintGCDetails` :详细 GC 日志模式，这两个都是默认关闭的)。

使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm 的参数。尤其在线上的环境特别有用,请看下面的例子：

`jinfo -flag [+|-]name vmid` 开启或者关闭对应名称的参数。

```xml
C:\Users\SnailClimb>jinfo  -flag  PrintGC 17340
-XX:-PrintGC

C:\Users\SnailClimb>jinfo  -flag  +PrintGC 17340

C:\Users\SnailClimb>jinfo  -flag  PrintGC 17340
-XX:+PrintGC
```

#### jmap： Java内存映像工具 

`jmap`（Memory Map for Java）命令用于生成**堆转储快照**。 如果不使用 `jmap` 命令，要想获取 Java 堆转储，可以使用 `“-XX:+HeapDumpOnOutOfMemoryError”` 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 `kill -3` 发送进程退出信号也能拿到 dump 文件。

```xml
jmap -dump:format=b,file=<dumpfile.hprof> <pid>
```

#### jhat： 虚拟机堆转储快照分析工具 

来分析jmap生成的**堆转储快照**。 

```xml
jhat xx/xx/x/x/heap.hprof
```

**jhat** 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。

#### jstack： Java堆栈跟踪工具 

jstack 命令用于生成**虚拟机当前时刻的线程快照** ，

**线程快照**就是当前虚拟机内每一条线程正在执行的方法堆栈的集合， 生成线程快照的主要目的是定位线程出现长时间停顿的原因， 如线程间死锁、 死循环、 请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈， 就可以知道没有响应的线程到底在后台做些
什么事情， 或者等待着什么资源。 

```xml
C： \Users\IcyFenix＞ jstack-l 3500
2010-11-19 23： 11： 26
Full thread dump Java HotSpot（ TM） 64-Bit Server VM（ 17.1-b03 mixed mode） ：
"[ThreadPool Manager]-Idle Thread"daemon prio=6 tid=0x0000000039dd4000 nid=0xf50 in Object.wait（ ） [0x000000003c96f000]
java.lang.Thread.State： WAITING（ on object monitor）
at java.lang.Object.wait（ Native Method）
-waiting on＜ 0x0000000016bdcc60＞ （ a org.eclipse.equinox.internal.util.impl.tpt.threadpool.Executor）
at java.lang.Object.wait（ Object.java： 485）
at org.eclipse.equinox.internal.util.impl.tpt.threadpool.Executor.run（ Executor.java： 106）
-locked＜ 0x0000000016bdcc60＞ （ a org.eclipse.equinox.internal.util.impl.tpt.threadpool.Executor）
Locked ownable synchronizers：
-None
```



#### OutOfMemoryError 排查

可以复现的话，用`jmap -dump:format=b,file=<dumpfile.hprof> <pid>`，生成dump文件 ，或者可以使用 `“-XX:+HeapDumpOnOutOfMemoryError”` 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，`heapdump-16546541.hprof`，用 mat(MemoryAnalyzer) 分析



Linux 内核有个机制叫OOM killer（Out-Of-Memory killer），该机制会监控那些占用内存过大，尤其是瞬间很快消耗大量内存的进程，为了防止内存耗尽而内核会把该进程杀掉。

```xml
grep "Out of memory" /var/log/messages  
```